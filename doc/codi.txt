                                                                        *codi*
             .------------.~
             |    .---.   |    .---.     .----.     ---.---~
             |   /        |   /     \    |     \       |~
             |  (         |  (       )   |      |      |~
             |   \        |   \     /    |     /       |~
             |    '---'   |    '---'     '----'     ---'---~
             '------------'~
              The interactive scratchpad for hackers.~

Author:   Ethan Chan <metakirby5@gmail.com>
License:  MIT
Repo:     https://github.com/metakirby5/codi.vim

==============================================================================
TABLE OF CONTENTS                                              *codi-contents*

INTRODUCTION...............................................|codi-introduction|
DEPENDENCIES...............................................|codi-dependencies|
USAGE.............................................................|codi-usage|
CONFIGURATION.............................................|codi-configuration|
INTERPRETERS...............................................|codi-interpreters|

==============================================================================
INTRODUCTION                                               *codi-introduction*

Codi is an interactive scratchpad for hackers, with a similar interface to
Numi (https://numi.io). It opens a pane synchronized to your main buffer which
displays the results of evaluating each line as you type (if Vim has |+job|,
asynchronously for supported interpreters). It's extensible to nearly any
language that provides a REPL (interactive interpreter)!

Watch a screencast at https://ptpb.pw/t/~codi!

==============================================================================
DEPENDENCIES                                               *codi-dependencies*

Asynchronous evaluation requires |+job|.

Command line utilities (BSD and Linux are both fine): script, uname.

Each interpreter also depends on its bin; see |codi-interpreters-bin|. These
are loaded on-demand. For example, if you only want to use the Python Codi
interpreter, you will not need ghci.

Default interpreter dependencies:
             Python:    python
             Javscript: node
             Haskell:   ghci
             Ruby:      irb
             Ocaml:     ocaml

==============================================================================
USAGE                                                             *codi-usage*

                                                                       *:Codi*
:Codi {filetype}
             Activates Codi for the current buffer, using the interpreter
             defined for {filetype}. If {filetype} is not specified, the
             buffer's 'filetype' is used instead.

                                                                      *:Codi!*
:Codi!
             Deactivates Codi for the current buffer.

                                                                     *:Codi!!*
:Codi!! {filetype}
             Toggles Codi for the current buffer.

SHELL WRAPPER~

             A nice way to use Codi is through a shell wrapper that you can
             stick in your ~/.bashrc:
>
             # Codi
             # Usage: codi [filetype] [filename]
             codi() {
               vim $2 -c \
                 "let g:startify_disable_at_vimenter = 1 |\
                 set buftype=nofile laststatus=0 nonu nornu |\
                 hi ColorColumn ctermbg=NONE |\
                 hi VertSplit ctermbg=NONE |\
                 hi NonText ctermfg=0 |\
                 Codi ${1:-python}"
             }
<
==============================================================================
CONFIGURATION                                             *codi-configuration*

                                                         *g:codi#interpreters*
g:codi#interpreters
             A dictionary of user-defined interpreters.
             See |codi-interpreters| for the format specification.

             This will not overwrite the internal default interpreters.
>
             let g:codi#interpreters = {
                   \ 'python': {
                       \ 'bin': 'python',
                       \ 'prompt': '^\(>>>\|\.\.\.\) ',
                       \ },
                   \ }
<
             Default value is {}.

                                                              *g:codi#aliases*
g:codi#aliases
             A dictionary of user-defined interpreter filetype aliases.
             This allows you to use an interpreter for more than one
             filetype. For example, you can alias "javascript.jsx" to
             "javascript" so the Javascript interpreter (node) can be used
             for the "javascript.jsx" filetype.

             This will not overwrite the internal default aliases.
>
             let g:codi#aliases = {
                   \ 'javascript.jsx': 'javascript',
                   \ }
<
             Default value is {}.

                                                                *g:codi#width*
g:codi#width
             The width of the Codi split.

             Default value is 40.

                                                           *g:codi#rightsplit*
g:codi#rightsplit
             Whether or not to spawn Codi on the right side of the current
             buffer.

             Default value is 1.

                                                           *g:codi#rightalign*
g:codi#rightalign
             Whether or not to right-align the Codi buffer.

             Default value is 1.

                                                            *g:codi#autoclose*
g:codi#autoclose
             Whether or not to close Codi when the associated buffer is
             closed.

             Default value is 1.

                                                                  *g:codi#raw*
g:codi#raw
             Whether or not to display interpreter results without
             formatting each expression to align with the line numbers.
             Useful if you are debugging a |codi-interpreters-preprocess|.

             Default value is 0.

==============================================================================
INTERPRETERS                                               *codi-interpreters*

Codi relies on interpreter configurations to understand how to evaluate your
buffer's contents. A number of default interpreters are bundled in, but you
can easily create your own configurations to add support for more filetypes.

DEFAULT INTERPRETERS                              *codi-interpreters-defaults*

Codi currently has support for the following filetypes:

             +-----------------------------+
             | Filetype   | bin    | async |
             +------------+--------+-------+
             | python     | python | yes   |
             | javascript | node   | no    |
             | haskell    | ghci   | yes   |
             | ruby       | irb    | yes   |
             | ocaml      | ocaml  | yes   |
             +-----------------------------+

OUTPUT SPECIFICATION                           *codi-interpreters-output-spec*

To ensure evaluated lines align with the corresponding buffer's lines, the
output prior to formatting (as if you had enabled |g:codi#raw|) must follow
this spec:
>
             [any number of lines]
             [prompt][any text]
             [any number of lines]
             [result associated with prompt, no leading whitespace]
             [any number of lines with leading whitespace]
             [next prompt][any text]
             ...
<
So, the following would be valid, assuming the prompt regex is "^> ":
>
             > 1 + 1                                | prompt 1
             2                                      | result 1
             > make_stacktrace()                    | prompt 2
             A BAD ERROR                            | result 2
               stacktrace line 1                    | ignored
               stacktrace line 2                    | ignored
               stacktrace line 3                    | ignored
             > function_that_prints_and_returns_1() | prompt 3
             I printed something!                   | ignored
             1                                      | result 3
             > and so on...                         | prompt 4
<
However, be careful of the following cases:
>
             > 1 + 1      | prompt 1
              2           | IGNORED (leading whitespace)
             > return_1() | prompt 2
             1            | IGNORED (next line has no leading whitespace)
             Returned 1.  | result 2
<
If your output does not follow spec, you MUST implement
|codi-interpreters-preprocess|.
The easiest way to check is to enable |g:codi#raw|.

EXAMPLE INTERPRETER CONFIGURATION                  *codi-interpreters-example*

A full interpreter configuration for Javascript can be found below. (Note that
in Vimscript, you still need to add forwardslashes for continuing newlines.)
>
             'javascript': {
                 'bin': 'node',
                 'env': 'NODE_DISABLE_COLORS=1',
                 'prompt': '^\(>\|\.\.\.\+\) ',
                 'preprocess': function('s:pp_js'),
                 'rephrase': function('s:rp_js'),
                 'async': 0,
             }
<
POSSIBLE ATTRIBUTES                             *codi-interpreters-attributes*

Interpreter configurations have an number of attributes, but only a few of
them are required. However, you may need to use the optional attributes
to get your interpreter to successfully work.

                                                       *codi-interpreters-bin*
bin (REQUIRED)
             Defines the command to use for the REPL backing the interpreter.
             For example, it would be "python" for Python, "node" for
             Javascript, and "irb" for Ruby.

                                                    *codi-interpreters-prompt*
prompt (REQUIRED)
             A vim-style regex pattern that exactly matches the prompt of
             bin. This will be used to correctly line up the output of bin
             with your buffer.

             In the Javascript example, we set prompt to match
             ">", "...", and any amount of dots greater than that to
             accomodate further nesting levels.

                                                       *codi-interpreters-env*
env (OPTIONAL)
             Any environment variables to set for bin. The format is
             "VARIABLE=value", as if you were running a command with
             environment variables at the command line.

             In the Javascript example, we enable "NODE_DISABLE_COLORS"
             so we have to strip less control characters.

             Default value is ''.

                                                *codi-interpreters-preprocess*
preprocess (OPTIONAL)
             A function to adjust the output of bin after running the buffer
             contents. Useful if control characters need to be filtered out,
             or if the output is non-standard in any way. After preprocess,
             the output should conform to |codi-interpreters-output-spec|.
             That way, output result lines can be successfully lined up with
             the corresponding lines.

             The function should take a single string argument that is the
             output of bin, and return a single string that is the adjusted
             output of bin.

             When creating your own preprocess, it is useful to enable
             |g:codi#raw| to see what the output initially looks like, and
             what your preprocess function does to the output.

             In the Javascript example, "node" has a tendency to print out
             control characters with a pattern of  (esc) followed by three
             characters, so we strip those with the following function:
>
             function! s:pp_js(evaled)
               return substitute(a:evaled, '...', '', 'g')
             endfunction
<
             Notice that in the example, preprocess is configured as
             `function('s:pp_js')`. In case you are unfamiliar with Vimscript,
             this is the construct that is normally used to pass functions as
             data.

             Default value is the identity function.

                                                  *codi-interpreters-rephrase*
rephrase (OPTIONAL)
             A function to adjust the contents of the current buffer to,
             before it is sent to bin. Useful if you need to modify certain
             lines to get them to evaluate to your liking.

             The function should take a single string argument that is the
             contents of the current buffer, and return a single string that
             is the adjusted contents to send to bin.

             This attribute is actually not recommended, since it is very
             difficult to achieve desired goals without unforeseen
             side-effects. None of the default interpreters actually use
             rephrase. However, for example, if you REALLY want
             "let var x = 5" to show "5" instead of "undefined", this is the
             way to do it.

             The configuration process is similar to preproccess, so just look
             at |codi-interpreters-preprocess| if you're unsure how to start.

             Default value is the identity function.

                                                     *codi-interpreters-async*
async (OPTIONAL)
             Whether or not bin should be run asynchronously. Async works fine
             most of the time, so you shouldn't have to touch this. Node is a
             notable exception, and I don't know why yet, so that's why this
             option exists.

             If your bin fails to generate any output in the Codi pane with
             |g:codi#raw| enabled, try enabling this.

             Note that if running synchronously,
             |CursorHold| and |CursorHoldI| will be used instaed of
             |TextChanged| and |TextChangedI| to make typing bearable.

             Default value is 1.

vim:ft=help:tw=78:sw=13:norl:
