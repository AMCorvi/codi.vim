                                                                        *codi*
             .------------.~
             |    .---.   |    .---.     .----.     ---.---~
             |   /        |   /     \    |     \       |~
             |  (         |  (       )   |      |      |~
             |   \        |   \     /    |     /       |~
             |    '---'   |    '---'     '----'     ---'---~
             '------------'~
              The interactive scratchpad for hackers.~

Author:   Ethan Chan <metakirby5@gmail.com>
License:  MIT
Repo:     https://github.com/metakirby5/codi.vim

==============================================================================
TABLE OF CONTENTS                                              *codi-contents*

INTRODUCTION...............................................|codi-introduction|
DEPENDENCIES...............................................|codi-dependencies|
USAGE.............................................................|codi-usage|
CONFIGURATION.............................................|codi-configuration|
INTERPRETERS...............................................|codi-interpreters|

==============================================================================
INTRODUCTION                                               *codi-introduction*

Codi is an interactive scratchpad for hackers, with a similar interface to
Numi (https://numi.io). It opens a pane synchronized to your main buffer which
displays the results of evaluating each line as you type. It's extensible to
nearly any language that provides an interactive interpreter!

Watch a screencast at https://ptpb.pw/t/~codi!

==============================================================================
DEPENDENCIES                                               *codi-dependencies*

Command line utilities (BSD and Linux are both fine): script, awk, uname

Each interpreter also depends on its bin; see |codi-interpreters-bin|.

Default interpreter dependencies:
             Python:    python
             Javscript: node
             Haskell:   ghci
             Ruby:      irb

==============================================================================
USAGE                                                             *codi-usage*

                                                                       *:Codi*
:Codi {filetype}
             Activates Codi for the current buffer, using the interpreter
             defined for {filetype}. If {filetype} is not specified, the
             buffer's 'filetype' is used instead.

                                                                      *:Codi!*
:Codi!
             Deactivates Codi for the current buffer.

                                                                     *:Codi!!*
:Codi!! {filetype}
             Toggles Codi for the current buffer.

==============================================================================
CONFIGURATION                                             *codi-configuration*

                                                         *g:codi#interpreters*
g:codi#interpreters
             A dictionary of user-defined interpreters.
             See |codi-interpreters| for the format specification.

             This will not overwrite the internal default interpreters.
>
             let g:codi#interpreters = {
                   \ 'javascript': {
                       \ 'bin': 'node',
                       \ 'deps': ['sed'],
                       \ 'env': 'NODE_DISABLE_COLORS=1',
                       \ 'prompt': '^(\^D|)*(>|\.{3,}) ',
                       \ 'rephrase':
                         \ 'sed "s/^\s*\(var\|let\)\s*\(\w\+\)\s*'
                         \.'=[^{]*$/&; \2/"',
                       \ 'preprocess': 'sed "s/...//g"',
                       \ },
                   \ }
<
             Default value is {}.

                                                              *g:codi#aliases*
g:codi#aliases
             A dictionary of user-defined interpreter filetype aliases.
             This allows you to use an interpreter for more than one
             filetype. For example, you can alias "javascript.jsx" to
             "javascript" so the Javascript interpreter (node) can be used
             for the "javascript.jsx" filetype.

             This will not overwrite the internal default aliases.
>
             let g:codi#aliases = {
                   \ 'javascript.jsx': 'javascript',
                   \ }
<
             Default value is {}.

                                                                *g:codi#width*
g:codi#width
             The width of the Codi split.

             Default value is 40.

                                                           *g:codi#rightalign*
g:codi#rightalign
             Whether or not to right-align the Codi buffer.

             Default value is 1.

                                                            *g:codi#autoclose*
g:codi#autoclose
             Whether or not to close Codi when the associated buffer is
             closed.

             Default value is 1.

                                                                  *g:codi#raw*
g:codi#raw
             Whether or not to display interpreter results without
             formatting each expression to align with the line numbers.
             Useful if you are debugging a |codi-interpreters-preprocess|.


==============================================================================
INTERPRETERS                                               *codi-interpreters*

Codi can be easily configured to use user-defined interpreters for langauges.
A full interpreter configuration for Javascript is given below.

                                                   *codi-interpreters-example*
>
             'javascript': {
               \ 'bin': 'node',
               \ 'deps': ['sed'],
               \ 'env': 'NODE_DISABLE_COLORS=1',
               \ 'prompt': '^(\^D|)*(>|\.{3,}) ',
               \ 'rephrase':
                 \ 'sed "s/^\s*\(var\|let\)\s*\(\w\+\)\s*'
                 \.'=[^{]*$/&; \2/"',
               \ 'preprocess': 'sed "s/...//g"',
               \ },
<

POSSIBLE ATTRIBUTES~

                                                       *codi-interpreters-bin*
bin (REQUIRED)
             Defines the command to use for the REPL backing the interpreter.
             For example, it would be "python" for Python, "node" for
             Javascript, and "irb" for Ruby.

                                                    *codi-interpreters-prompt*
prompt (REQUIRED)
             An awk-style regex pattern that exactly matches the prompt of
             bin. This will be used to correctly line up the output of bin
             with your buffer.

             In the Javascript example, we set propmt to match
             ">", "...", and any amount of dots greater than that to
             accomodate further nesting levels. We also include ^D and ,
             because those are (for some reason or another) prepended to the
             first prompt.

                                                       *codi-interpreters-env*
env (OPTIONAL)
             Any environment variables to set for bin. The format is
             "VARIABLE=value", as if you were running a command with
             environment variables at the command line.

             In the Javascript example, we enable "NODE_DISABLE_COLORS"
             so we have to strip less control characters.

                                                      *codi-interpreters-deps*
deps (OPTIONAL)
             Any dependencies for the interpreter. Ensures that users of this
             interpreter cannot use it without all of the deps.

             In the Javascript example, we add "sed" because we make use
             of it in rephrase and preprocess.

                                                  *codi-interpreters-rephrase*
rephrase (OPTIONAL)
             A command to pipe the current buffer to, before it is sent to
             bin. Useful if you need to modify certain lines to get
             them to evaluate to your liking.

             In the Javascript example, we rephrase simple assignment
             statements with "let" or "var" (i.e. those not ending in "{")
             to append the variable being let/var to the end. This allows
             the overall evaluated result to be the variable being let/var,
             rather than undefined.

                                                *codi-interpreters-preprocess*
preprocess (OPTIONAL)
             A command to pipe the output of bin to, before it is formatted.
             Useful if control characters need to be filtered out from running
             bin, or if the output is non-standard in any way. After piping
             through preprocess, the output of bin should look palatable.

             In the Javascript example, "node" has a tendency to print out
             control characters with a pattern of  (esc) followed by three
             characters, so we strip those.

vim:ft=help:tw=78:sw=13:norl:
