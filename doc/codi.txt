                                                                        *codi*
             .------------.~
             |    .---.   |    .---.     .----.     ---.---~
             |   /        |   /     \    |     \       |~
             |  (         |  (       )   |      |      |~
             |   \        |   \     /    |     /       |~
             |    '---'   |    '---'     '----'     ---'---~
             '------------'~
              The interactive scratchpad for hackers.~

Author:   Ethan Chan <metakirby5@gmail.com>
License:  MIT
Repo:     https://github.com/metakirby5/codi.vim

==============================================================================
TABLE OF CONTENTS                                              *codi-contents*

INTRODUCTION...............................................|codi-introduction|
DEPENDENCIES...............................................|codi-dependencies|
USAGE.............................................................|codi-usage|
CONFIGURATION.............................................|codi-configuration|
INTERPRETERS...............................................|codi-interpreters|

==============================================================================
INTRODUCTION                                               *codi-introduction*

Codi is an interactive scratchpad for hackers, with a similar interface to
Numi (https://numi.io). It opens a pane synchronized to your main buffer which
displays the results of evaluating each line as you type (if Vim has |+job|,
asynchronously for supported interpreters). It's extensible to nearly any
language that provides an interactive interpreter!

Watch a screencast at https://ptpb.pw/t/~codi!

==============================================================================
DEPENDENCIES                                               *codi-dependencies*

Asynchronous evaluation requires |+job|.

Command line utilities (BSD and Linux are both fine): script, uname.

Each interpreter also depends on its bin; see |codi-interpreters-bin|. These
are loaded on-demand. For example, if you only want to use the Python Codi
interpreter, you will not need ghci.

Default interpreter dependencies:
             Python:    python
             Javscript: node
             Haskell:   ghci
             Ruby:      irb

==============================================================================
USAGE                                                             *codi-usage*

                                                                       *:Codi*
:Codi {filetype}
             Activates Codi for the current buffer, using the interpreter
             defined for {filetype}. If {filetype} is not specified, the
             buffer's 'filetype' is used instead.

                                                                      *:Codi!*
:Codi!
             Deactivates Codi for the current buffer.

                                                                     *:Codi!!*
:Codi!! {filetype}
             Toggles Codi for the current buffer.

SHELL WRAPPER~

             A nice way to use Codi is through a shell wrapper that you can
             stick in your ~/.bashrc:
>
             # Codi
             # Usage: codi [filetype] [filename]
             codi() {
               vim $2 -c \
                 "let g:startify_disable_at_vimenter = 1 |\
                 set laststatus=0 nonu nornu |\
                 hi ColorColumn ctermbg=NONE |\
                 hi VertSplit ctermbg=NONE |\
                 hi NonText ctermfg=0 |\
                 Codi ${1:-python}"
             }
<
==============================================================================
CONFIGURATION                                             *codi-configuration*

                                                         *g:codi#interpreters*
g:codi#interpreters
             A dictionary of user-defined interpreters.
             See |codi-interpreters| for the format specification.

             This will not overwrite the internal default interpreters.
>
             let g:codi#interpreters = {
                   \ 'python': {
                       \ 'bin': 'python',
                       \ 'prompt': '^\(>>>\|\.\.\.\) ',
                       \ },
                   \ }
<
             Default value is {}.

                                                              *g:codi#aliases*
g:codi#aliases
             A dictionary of user-defined interpreter filetype aliases.
             This allows you to use an interpreter for more than one
             filetype. For example, you can alias "javascript.jsx" to
             "javascript" so the Javascript interpreter (node) can be used
             for the "javascript.jsx" filetype.

             This will not overwrite the internal default aliases.
>
             let g:codi#aliases = {
                   \ 'javascript.jsx': 'javascript',
                   \ }
<
             Default value is {}.

                                                                *g:codi#width*
g:codi#width
             The width of the Codi split.

             Default value is 40.

                                                           *g:codi#rightsplit*
g:codi#rightsplit
             Whether or not to spawn Codi on the right side of the current
             buffer.

             Default value is 1.

                                                           *g:codi#rightalign*
g:codi#rightalign
             Whether or not to right-align the Codi buffer.

             Default value is 1.

                                                            *g:codi#autoclose*
g:codi#autoclose
             Whether or not to close Codi when the associated buffer is
             closed.

             Default value is 1.

                                                                  *g:codi#raw*
g:codi#raw
             Whether or not to display interpreter results without
             formatting each expression to align with the line numbers.
             Useful if you are debugging a |codi-interpreters-preprocess|.

             Default value is 0.

==============================================================================
INTERPRETERS                                               *codi-interpreters*

Codi relies on interpreter configurations to understand how to evaluate your
buffer's contents. A number of default interpreters are bundled in, but you
can easily create your own configurations to add support for more filetypes.

DEFAULT INTERPRETERS~

Codi currently has support for the following filetypes:

             +-----------------------------+
             | Filetype   | bin    | async |
             | ---------- | ------ | ----- |
             | python     | python | yes   |
             | javascript | node   | no    |
             | haskell    | ghci   | yes   |
             | ruby       | irb    | yes   |
             +-----------------------------+

EXAMPLE INTERPRETER CONFIGURATION~

A full interpreter configuration for Javascript can be found below. (Note that
in Vimscript, you still need to add forwardslashes for continuing newlines.)
>
             'javascript': {
                 'bin': 'node',
                 'env': 'NODE_DISABLE_COLORS=1',
                 'prompt': '^\(>\|\.\.\.\+\) ',
                 'preprocess': function('s:pp_js'),
                 'rephrase': function('s:rp_js'),
                 'async': 0,
             }
<
POSSIBLE ATTRIBUTES~

Interpreter configurations have an number of attributes, but only a few of
them are required. However, you may need to use the optional attributes
to get your interpreter to successfully work.

                                                       *codi-interpreters-bin*
bin (REQUIRED)
             Defines the command to use for the REPL backing the interpreter.
             For example, it would be "python" for Python, "node" for
             Javascript, and "irb" for Ruby.

                                                    *codi-interpreters-prompt*
prompt (REQUIRED)
             A vim-style regex pattern that exactly matches the prompt of
             bin. This will be used to correctly line up the output of bin
             with your buffer.

             In the Javascript example, we set prompt to match
             ">", "...", and any amount of dots greater than that to
             accomodate further nesting levels.

                                                       *codi-interpreters-env*
env (OPTIONAL)
             Any environment variables to set for bin. The format is
             "VARIABLE=value", as if you were running a command with
             environment variables at the command line.

             In the Javascript example, we enable "NODE_DISABLE_COLORS"
             so we have to strip less control characters.

                                                *codi-interpreters-preprocess*
preprocess (OPTIONAL)
             A function to adjust the output of bin after running the buffer
             contents. Useful if control characters need to be filtered out,
             or if the output is non-standard in any way. After preprocess,
             the output should be very human-friendly. That way, output result
             lines can be successfully lined up with the corresponding lines.

             The function should take a single string argument that is the
             output of bin, and return a single string that is the adjusted
             output of bin.

             When creating your own preprocess, it is useful to enable
             g:codi#raw to see what the output initially looks like, and what
             your preprocess function does to the output.

             In the Javascript example, "node" has a tendency to print out
             control characters with a pattern of  (esc) followed by three
             characters, so we strip those with the following function:
>
             function! s:pp_js(evaled)
               return substitute(a:evaled, '...', '', 'g')
             endfunction
<
             Notice that in the example, preprocess is configured as
             `function('s:pp_js')`. In case you are unfamiliar with Vimscript,
             this is the construct that is normally used to pass functions as
             data.

                                                  *codi-interpreters-rephrase*
rephrase (OPTIONAL)
             A function to adjust the contents of the current buffer to,
             before it is sent to bin. Useful if you need to modify certain
             lines to get them to evaluate to your liking.

             The function should take a single string argument that is the
             contents of the current buffer, and return a single string that
             is the adjusted contents to send to bin.

             This attribute is actually not recommended, since it is very
             difficult to achieve desired goals without unforeseen
             side-effects. None of the default interpreters actually use
             rephrase. However, for example, if you REALLY want
             "let var x = 5" to show "5" instead of "undefined", this is the
             way to do it.

             The configuration process is similar to preproccess, so just look
             at |codi-interpreters-preprocess| if you're unsure how to start.

                                                     *codi-interpreters-async*
async (OPTIONAL)
             Whether or not bin should be run asynchronously. Async works fine
             most of the time, so you shouldn't have to touch this. Node is a
             notable exception, and I don't know why yet, so that's why this
             option exists.

             Note that if running synchronousy, |CursorHold| and |CursorHoldI|
             will be used instaed of |TextChanged| and |TextChangedI| to
             make typing bearable.

             Default value is 1.

vim:ft=help:tw=78:sw=13:norl:
